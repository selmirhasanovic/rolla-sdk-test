// Autogenerated from Pigeon (v25.5.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.rolla.band.sdk.generated

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
private object MessagesPigeonUtils {

  fun createConnectionError(channelName: String): FlutterError {
    return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")  }

  fun wrapResult(result: Any?): List<Any?> {
    return listOf(result)
  }

  fun wrapError(exception: Throwable): List<Any?> {
    return if (exception is FlutterError) {
      listOf(
        exception.code,
        exception.message,
        exception.details
      )
    } else {
      listOf(
        exception.javaClass.simpleName,
        exception.toString(),
        "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
      )
    }
  }
  fun deepEquals(a: Any?, b: Any?): Boolean {
    if (a is ByteArray && b is ByteArray) {
        return a.contentEquals(b)
    }
    if (a is IntArray && b is IntArray) {
        return a.contentEquals(b)
    }
    if (a is LongArray && b is LongArray) {
        return a.contentEquals(b)
    }
    if (a is DoubleArray && b is DoubleArray) {
        return a.contentEquals(b)
    }
    if (a is Array<*> && b is Array<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is List<*> && b is List<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is Map<*, *> && b is Map<*, *>) {
      return a.size == b.size && a.all {
          (b as Map<Any?, Any?>).containsKey(it.key) &&
          deepEquals(it.value, b[it.key])
      }
    }
    return a == b
  }
      
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/**
 * Bluetooth Low Energy service capabilities supported by devices
 *
 * These correspond to standard BLE service UUIDs:
 * - RSC: Running Speed and Cadence
 * - CSC: Cycling Speed and Cadence
 * - HR: Heart Rate
 */
enum class BluetoothCapabilities(val raw: Int) {
  /** Running Speed and Cadence service */
  RSC(0),
  /** Cycling Speed and Cadence service */
  CSC(1),
  /** Heart Rate service */
  HR(2);

  companion object {
    fun ofRaw(raw: Int): BluetoothCapabilities? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Bluetooth state response enum
 * state on
 */
enum class BluetoothState(val raw: Int) {
  POWERED_ON(0),
  /** state off */
  POWERED_OFF(1),
  /** bluetooth resetting - iOS only */
  RESETTING(2),
  /** unauthorized for use - iOS only */
  UNAUTHORIZED(3),
  /** bluetooth is turning off - Android only */
  TURNING_OFF(4),
  /** bluetooth is turning on - Android only */
  TURNING_ON(5),
  /** other cases */
  UNKNOWN(6);

  companion object {
    fun ofRaw(raw: Int): BluetoothState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Possible connection states for a Bluetooth device */
enum class ConnectionState(val raw: Int) {
  /** Device is successfully connected and ready for data transfer */
  CONNECTED(0),
  /** Device is not connected */
  DISCONNECTED(1),
  /** Connection attempt is in progress */
  CONNECTING(2);

  companion object {
    fun ofRaw(raw: Int): ConnectionState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Device type classification for filtering and UI purposes */
enum class DeviceType(val raw: Int) {
  /** Official Rolla Band device */
  ROLLA_BAND(0),
  /** Other compatible Bluetooth device */
  OTHER(1);

  companion object {
    fun ofRaw(raw: Int): DeviceType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Activity types for Rolla Band */
enum class BandActivityType(val raw: Int) {
  RUN(0),
  CYCLING(1),
  BADMINTON(2),
  FOOTBALL(3),
  TENNIS(4),
  YOGA(5),
  MEDITATION(6),
  DANCE(7),
  BASKETBALL(8),
  WALK(9),
  WORKOUT(10),
  CRICKET(11),
  HIKING(12),
  AEROBICS(13),
  PING_PONG(14),
  ROPE_JUMP(15),
  SIT_UPS(16),
  VOLLEYBALL(17);

  companion object {
    fun ofRaw(raw: Int): BandActivityType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Charging state of the Rolla Band */
enum class BandChargingState(val raw: Int) {
  CHARGING(0),
  NOT_CHARGING(1);

  companion object {
    fun ofRaw(raw: Int): BandChargingState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class RollaBandSleepStageValue(val raw: Int) {
  DEEP(0),
  LIGHT(1),
  REM(2),
  AWAKE(3);

  companion object {
    fun ofRaw(raw: Int): RollaBandSleepStageValue? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Represents a discovered or connected Bluetooth device
 *
 * Contains all necessary information about a Bluetooth device including
 * its capabilities, connection state, and device-specific metadata.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class BluetoothDevice (
  /** Human-readable device name (e.g., "Rolla Band Pro") */
  val name: String,
  /**
   * Received Signal Strength Indicator in dBm
   * Typical range: -100 (weak) to 0 (strong)
   */
  val rssi: Long,
  /**
   * Unique device identifier used for connection operations
   * Format varies by platform (UUID on iOS, MAC address on Android)
   */
  val uuid: String,
  /**
   * List of Bluetooth capabilities supported by this device
   * Used to determine what data can be received from the device
   */
  val capabilities: List<BluetoothCapabilities>,
  /** Current connection state of the device */
  val connectionState: ConnectionState,
  /** Type classification of the device */
  val deviceType: DeviceType
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): BluetoothDevice {
      val name = pigeonVar_list[0] as String
      val rssi = pigeonVar_list[1] as Long
      val uuid = pigeonVar_list[2] as String
      val capabilities = pigeonVar_list[3] as List<BluetoothCapabilities>
      val connectionState = pigeonVar_list[4] as ConnectionState
      val deviceType = pigeonVar_list[5] as DeviceType
      return BluetoothDevice(name, rssi, uuid, capabilities, connectionState, deviceType)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      name,
      rssi,
      uuid,
      capabilities,
      connectionState,
      deviceType,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is BluetoothDevice) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * User data for Rolla Band
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class UserData (
  val age: Long,
  val height: Double,
  val weight: Double,
  val gender: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): UserData {
      val age = pigeonVar_list[0] as Long
      val height = pigeonVar_list[1] as Double
      val weight = pigeonVar_list[2] as Double
      val gender = pigeonVar_list[3] as Long
      return UserData(age, height, weight, gender)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      age,
      height,
      weight,
      gender,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is UserData) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class GpsData (
  val latitude: Double,
  val longitude: Double,
  val altitude: Double,
  val timestamp: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GpsData {
      val latitude = pigeonVar_list[0] as Double
      val longitude = pigeonVar_list[1] as Double
      val altitude = pigeonVar_list[2] as Double
      val timestamp = pigeonVar_list[3] as Long
      return GpsData(latitude, longitude, altitude, timestamp)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      latitude,
      longitude,
      altitude,
      timestamp,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is GpsData) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Represents a single step measurement with timestamp and calories
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RollaBandStep (
  /** UTC timestamp when the steps were recorded */
  val timestamp: Long,
  /** Number of steps taken in this measurement period */
  val steps: Long,
  /** Calories burned during this measurement period */
  val calories: Double
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RollaBandStep {
      val timestamp = pigeonVar_list[0] as Long
      val steps = pigeonVar_list[1] as Long
      val calories = pigeonVar_list[2] as Double
      return RollaBandStep(timestamp, steps, calories)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      timestamp,
      steps,
      calories,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RollaBandStep) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Response containing steps data and sync timestamps
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RollaBandStepsSyncResponse (
  /** Array of step measurements */
  val steps: List<RollaBandStep>,
  /** Timestamp of the last synced block for future sync operations */
  val lastSyncedBlockTimestamp: Long,
  /** Timestamp of the last synced entry for future sync operations */
  val lastSyncedEntryTimestamp: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RollaBandStepsSyncResponse {
      val steps = pigeonVar_list[0] as List<RollaBandStep>
      val lastSyncedBlockTimestamp = pigeonVar_list[1] as Long
      val lastSyncedEntryTimestamp = pigeonVar_list[2] as Long
      return RollaBandStepsSyncResponse(steps, lastSyncedBlockTimestamp, lastSyncedEntryTimestamp)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      steps,
      lastSyncedBlockTimestamp,
      lastSyncedEntryTimestamp,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RollaBandStepsSyncResponse) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RollaBandHeartRate (
  val timestamp: Long,
  val hr: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RollaBandHeartRate {
      val timestamp = pigeonVar_list[0] as Long
      val hr = pigeonVar_list[1] as Long
      return RollaBandHeartRate(timestamp, hr)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      timestamp,
      hr,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RollaBandHeartRate) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RollaBandHeartRateSyncResponse (
  val heartRates: List<RollaBandHeartRate>,
  val activityLastSyncedBlockTimestamp: Long,
  val activityLastSyncedEntryTimestamp: Long,
  val passiveLastSyncedTimestamp: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RollaBandHeartRateSyncResponse {
      val heartRates = pigeonVar_list[0] as List<RollaBandHeartRate>
      val activityLastSyncedBlockTimestamp = pigeonVar_list[1] as Long
      val activityLastSyncedEntryTimestamp = pigeonVar_list[2] as Long
      val passiveLastSyncedTimestamp = pigeonVar_list[3] as Long
      return RollaBandHeartRateSyncResponse(heartRates, activityLastSyncedBlockTimestamp, activityLastSyncedEntryTimestamp, passiveLastSyncedTimestamp)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      heartRates,
      activityLastSyncedBlockTimestamp,
      activityLastSyncedEntryTimestamp,
      passiveLastSyncedTimestamp,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RollaBandHeartRateSyncResponse) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RollaBandHRV (
  val timestamp: Long,
  val hrv: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RollaBandHRV {
      val timestamp = pigeonVar_list[0] as Long
      val hrv = pigeonVar_list[1] as Long
      return RollaBandHRV(timestamp, hrv)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      timestamp,
      hrv,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RollaBandHRV) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RollaBandHRVSyncResponse (
  val hrvs: List<RollaBandHRV>,
  val lastSyncedBlockTimestamp: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RollaBandHRVSyncResponse {
      val hrvs = pigeonVar_list[0] as List<RollaBandHRV>
      val lastSyncedBlockTimestamp = pigeonVar_list[1] as Long
      return RollaBandHRVSyncResponse(hrvs, lastSyncedBlockTimestamp)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      hrvs,
      lastSyncedBlockTimestamp,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RollaBandHRVSyncResponse) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RollaBandSleepStage (
  val startTime: Long,
  val endTime: Long,
  val value: RollaBandSleepStageValue
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RollaBandSleepStage {
      val startTime = pigeonVar_list[0] as Long
      val endTime = pigeonVar_list[1] as Long
      val value = pigeonVar_list[2] as RollaBandSleepStageValue
      return RollaBandSleepStage(startTime, endTime, value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      startTime,
      endTime,
      value,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RollaBandSleepStage) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class RollaBandSleepSyncResponse (
  val sleepStages: List<RollaBandSleepStage>,
  val lastSyncedBlockTimestamp: Long,
  val lastSyncedEntryTimestamp: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RollaBandSleepSyncResponse {
      val sleepStages = pigeonVar_list[0] as List<RollaBandSleepStage>
      val lastSyncedBlockTimestamp = pigeonVar_list[1] as Long
      val lastSyncedEntryTimestamp = pigeonVar_list[2] as Long
      return RollaBandSleepSyncResponse(sleepStages, lastSyncedBlockTimestamp, lastSyncedEntryTimestamp)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      sleepStages,
      lastSyncedBlockTimestamp,
      lastSyncedEntryTimestamp,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RollaBandSleepSyncResponse) {
      return false
    }
    if (this === other) {
      return true
    }
    return MessagesPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}
private open class MessagesPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          BluetoothCapabilities.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          BluetoothState.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          ConnectionState.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          DeviceType.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          BandActivityType.ofRaw(it.toInt())
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          BandChargingState.ofRaw(it.toInt())
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RollaBandSleepStageValue.ofRaw(it.toInt())
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          BluetoothDevice.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          UserData.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GpsData.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RollaBandStep.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RollaBandStepsSyncResponse.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RollaBandHeartRate.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RollaBandHeartRateSyncResponse.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RollaBandHRV.fromList(it)
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RollaBandHRVSyncResponse.fromList(it)
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RollaBandSleepStage.fromList(it)
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RollaBandSleepSyncResponse.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is BluetoothCapabilities -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is BluetoothState -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is ConnectionState -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is DeviceType -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is BandActivityType -> {
        stream.write(133)
        writeValue(stream, value.raw)
      }
      is BandChargingState -> {
        stream.write(134)
        writeValue(stream, value.raw)
      }
      is RollaBandSleepStageValue -> {
        stream.write(135)
        writeValue(stream, value.raw)
      }
      is BluetoothDevice -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is UserData -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is GpsData -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is RollaBandStep -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is RollaBandStepsSyncResponse -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is RollaBandHeartRate -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is RollaBandHeartRateSyncResponse -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is RollaBandHRV -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      is RollaBandHRVSyncResponse -> {
        stream.write(144)
        writeValue(stream, value.toList())
      }
      is RollaBandSleepStage -> {
        stream.write(145)
        writeValue(stream, value.toList())
      }
      is RollaBandSleepSyncResponse -> {
        stream.write(146)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/**
 * API for Flutter to call native platform Bluetooth operations
 *
 * This interface defines methods that Flutter can call to interact with
 * the native Bluetooth stack. All methods are asynchronous to prevent
 * blocking the UI thread.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface RollaBluetoothHostApi {
  /**
   * Starts scanning for Bluetooth devices
   *
   * [deviceTypes] - Types of devices to scan for (filters results)
   * [scanDuration] - How long to scan in milliseconds (default: 10 seconds)
   *
   * Results are delivered via [RollaBluetoothFlutterApi.onDevicesFound]
   */
  fun scanForDevices(deviceTypes: List<DeviceType>, scanDuration: Long, callback: (Result<Unit>) -> Unit)
  /**
   * Stops any active Bluetooth scanning operation
   *
   * Should be called when the user navigates away from device discovery
   * or when sufficient devices have been found.
   */
  fun stopScanning(callback: (Result<Unit>) -> Unit)
  /**
   * Attempts to connect to a specific Bluetooth device
   *
   * [uuid] - Unique identifier of the device to connect to
   *
   * Returns true if connection was initiated successfully.
   * Connection state changes are delivered via
   * [RollaBluetoothFlutterApi.onConnectionStateChanged]
   */
  fun connectToDevice(uuid: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Disconnects from a specific Bluetooth device
   *
   * [uuid] - Unique identifier of the device to disconnect from
   *
   * Returns true if disconnection was initiated successfully.
   * Connection state changes are delivered via
   * [RollaBluetoothFlutterApi.onConnectionStateChanged]
   */
  fun disconnectFromDevice(uuid: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Disconnects and removes system bond (Android only; no-op on iOS)
   *
   * [uuid] - MAC address on Android; ignored on iOS
   * Returns true if the device was disconnected and bond removed (or no bond existed).
   */
  fun disconnectAndRemoveBond(uuid: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Checks the connection state of a specific Bluetooth device
   *
   * [uuid] - Unique identifier of the device to check
   *
   * Returns the current connection state of the device as [ConnectionState].
   */
  fun checkConnectionState(uuid: String, callback: (Result<ConnectionState>) -> Unit)
  /**
   * Checks the current Bluetooth state
   *
   * Returns the current Bluetooth state as [BluetoothState].
   */
  fun checkBluetoothState(callback: (Result<BluetoothState>) -> Unit)

  companion object {
    /** The codec used by RollaBluetoothHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
    /** Sets up an instance of `RollaBluetoothHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: RollaBluetoothHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothHostApi.scanForDevices$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val deviceTypesArg = args[0] as List<DeviceType>
            val scanDurationArg = args[1] as Long
            api.scanForDevices(deviceTypesArg, scanDurationArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothHostApi.stopScanning$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.stopScanning{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothHostApi.connectToDevice$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            api.connectToDevice(uuidArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothHostApi.disconnectFromDevice$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            api.disconnectFromDevice(uuidArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothHostApi.disconnectAndRemoveBond$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            api.disconnectAndRemoveBond(uuidArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothHostApi.checkConnectionState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            api.checkConnectionState(uuidArg) { result: Result<ConnectionState> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothHostApi.checkBluetoothState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.checkBluetoothState{ result: Result<BluetoothState> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for native platforms to send data back to Flutter
 *
 * This interface defines callbacks that the native platform can invoke
 * to notify Flutter of Bluetooth events and data updates.
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class RollaBluetoothFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by RollaBluetoothFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
  }
  /**
   * Called when new devices are discovered during scanning
   *
   * [devices] - List of discovered devices with their current information
   *
   * This method may be called multiple times during a scan as new devices
   * are discovered or existing devices update their information.
   */
  fun onDevicesFound(devicesArg: List<BluetoothDevice>, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothFlutterApi.onDevicesFound$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(devicesArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Called when a device's connection state changes
   *
   * [uuid] - Unique identifier of the device
   * [state] - New connection state
   *
   * This is called for both successful and failed connection attempts,
   * as well as unexpected disconnections.
   */
  fun onConnectionStateChanged(uuidArg: String, stateArg: ConnectionState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothFlutterApi.onConnectionStateChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(uuidArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Called when the Bluetooth adapter state changes
   *
   * [state] - New Bluetooth state
   *
   * This is called when Bluetooth is turned on/off, becomes unauthorized,
   * or encounters other state changes that affect device connectivity.
   */
  fun onBluetoothStateChanged(stateArg: BluetoothState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.RollaBluetoothFlutterApi.onBluetoothStateChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/**
 * API for native platforms to send data back to Flutter
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class RollaBandActivityApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by RollaBandActivityApi. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
  }
  /**
   * Called when heart rate data is received from the Rolla Band
   *
   * [heartRate] - Heart rate in beats per minute (BPM)
   */
  fun onHeartRateReceived(heartRateArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.RollaBandActivityApi.onHeartRateReceived$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(heartRateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Called when running speed and cadence data is received from the Rolla Band
   *
   * [speed] - Speed in meters per second (m/s)
   * [cadence] - Cadence in steps per minute (spm)
   * [steps] - Steps calculated for this measurement period (can be fractional)
   */
  fun onRunningSpeedAndCadenceReceived(speedArg: Double, cadenceArg: Long, stepsArg: Double, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.RollaBandActivityApi.onRunningSpeedAndCadenceReceived$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(speedArg, cadenceArg, stepsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/**
 * API for Flutter to call native platform Bluetooth operations
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface RollaBandWorkoutHostApi {
  fun startWorkout(uuid: String, type: BandActivityType, callback: (Result<Unit>) -> Unit)
  fun stopWorkout(uuid: String, type: BandActivityType, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by RollaBandWorkoutHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
    /** Sets up an instance of `RollaBandWorkoutHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: RollaBandWorkoutHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBandWorkoutHostApi.startWorkout$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            val typeArg = args[1] as BandActivityType
            api.startWorkout(uuidArg, typeArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBandWorkoutHostApi.stopWorkout$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            val typeArg = args[1] as BandActivityType
            api.stopWorkout(uuidArg, typeArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for Flutter to call native platform Location operations
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface LocationHostApi {
  fun requestAlwaysLocationPermission(callback: (Result<Unit>) -> Unit)
  fun startLocationTracking(type: BandActivityType, callback: (Result<Unit>) -> Unit)
  fun stopLocationTracking(callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by LocationHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
    /** Sets up an instance of `LocationHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: LocationHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.LocationHostApi.requestAlwaysLocationPermission$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.requestAlwaysLocationPermission{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.LocationHostApi.startLocationTracking$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val typeArg = args[0] as BandActivityType
            api.startLocationTracking(typeArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.LocationHostApi.stopLocationTracking$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.stopLocationTracking{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for native platforms to send data back to Flutter
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class RollaBandGpsApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by RollaBandGpsApi. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
  }
  /**
   * Called when GPS data is received from native host platform
   *
   * [data] - [GpsData]
   *
   */
  fun onGpsDataReceived(dataArg: GpsData, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.RollaBandGpsApi.onGpsDataReceived$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(dataArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/**
 * API for Flutter to call native platform band operations
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface BandCommandHostAPI {
  /**
   * Update user data on the band
   *
   * [userData] - [UserData]
   */
  fun updateUserData(uuid: String, userData: UserData, callback: (Result<Unit>) -> Unit)
  /**
   * Get user data from the band
   *
   * Returns [UserData]
   */
  fun getUserData(uuid: String, callback: (Result<UserData>) -> Unit)
  fun getFirmwareVersion(uuid: String, callback: (Result<String>) -> Unit)
  fun getSerialNumber(uuid: String, callback: (Result<String>) -> Unit)
  fun getBatteryLevel(uuid: String, callback: (Result<Long>) -> Unit)

  companion object {
    /** The codec used by BandCommandHostAPI. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
    /** Sets up an instance of `BandCommandHostAPI` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: BandCommandHostAPI?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.BandCommandHostAPI.updateUserData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            val userDataArg = args[1] as UserData
            api.updateUserData(uuidArg, userDataArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.BandCommandHostAPI.getUserData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            api.getUserData(uuidArg) { result: Result<UserData> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.BandCommandHostAPI.getFirmwareVersion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            api.getFirmwareVersion(uuidArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.BandCommandHostAPI.getSerialNumber$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            api.getSerialNumber(uuidArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.BandCommandHostAPI.getBatteryLevel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            api.getBatteryLevel(uuidArg) { result: Result<Long> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for native platforms to send band battery data to Flutter
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class BandBatteryFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by BandBatteryFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
  }
  /**
   * Called when battery level is received from the Rolla Band
   *
   * [level] - Battery level in percentage (0-100)
   */
  fun onBatteryLevelReceived(levelArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.BandBatteryFlutterApi.onBatteryLevelReceived$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(levelArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class FirmwareProgressAPI(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by FirmwareProgressAPI. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
  }
  /**
   * Called when firmware update progress is received from the Rolla Band
   *
   * [progress] - Firmware update progress in percentage (0-100)
   */
  fun onFirmwareProgress(progressArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.FirmwareProgressAPI.onFirmwareProgress$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(progressArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /** Called when firmware update fails */
  fun onFirmwareUpdateError(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.FirmwareProgressAPI.onFirmwareUpdateError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onFirmwareUpdateCompleted(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.FirmwareProgressAPI.onFirmwareUpdateCompleted$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface FirmwareHostAPI {
  /**
   * Start firmware update
   *
   * [url] - file path to use the firmware from
   */
  fun startFirmwareUpdate(url: String, uuid: String, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by FirmwareHostAPI. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
    /** Sets up an instance of `FirmwareHostAPI` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: FirmwareHostAPI?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.FirmwareHostAPI.startFirmwareUpdate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val uuidArg = args[1] as String
            api.startFirmwareUpdate(urlArg, uuidArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                reply.reply(MessagesPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for native platforms to send band charging state to Flutter
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class BandChargingStateFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by BandChargingStateFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
  }
  /**
   * Called when charging state changes on the Rolla Band
   *
   * [state] - Current charging state
   */
  fun onChargingStateReceived(stateArg: BandChargingState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.rolla_band_sdk.BandChargingStateFlutterApi.onChargingStateReceived$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(MessagesPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/**
 * API for Flutter to call native platform health/steps operations
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface RollaBandHealthDataHostApi {
  /**
   * Fetches steps data from the connected Rolla Band
   *
   * [uuid] - Unique identifier of the device to fetch data from
   * [lastSyncedBlockTimestamp] - Cursor of the last synced block (0 for full sync)
   * [lastSyncedEntryTimestamp] - Cursor of the last synced entry (0 for full sync)
   *
   * Returns [RollaBandStepsSyncResponse] with steps and updated cursors
   */
  fun getStepsData(uuid: String, lastSyncedBlockTimestamp: Long, lastSyncedEntryTimestamp: Long, callback: (Result<RollaBandStepsSyncResponse>) -> Unit)
  fun getHeartRateData(uuid: String, activityLastSyncedBlockTimestamp: Long, activityLastSyncedEntryTimestamp: Long, passiveLastSyncedTimestamp: Long, callback: (Result<RollaBandHeartRateSyncResponse>) -> Unit)
  fun getHRVData(uuid: String, lastSyncedBlockTimestamp: Long, callback: (Result<RollaBandHRVSyncResponse>) -> Unit)
  fun getSleepData(uuid: String, lastSyncedBlockTimestamp: Long, lastSyncedEntryTimestamp: Long, callback: (Result<RollaBandSleepSyncResponse>) -> Unit)

  companion object {
    /** The codec used by RollaBandHealthDataHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      MessagesPigeonCodec()
    }
    /** Sets up an instance of `RollaBandHealthDataHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: RollaBandHealthDataHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBandHealthDataHostApi.getStepsData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            val lastSyncedBlockTimestampArg = args[1] as Long
            val lastSyncedEntryTimestampArg = args[2] as Long
            api.getStepsData(uuidArg, lastSyncedBlockTimestampArg, lastSyncedEntryTimestampArg) { result: Result<RollaBandStepsSyncResponse> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBandHealthDataHostApi.getHeartRateData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            val activityLastSyncedBlockTimestampArg = args[1] as Long
            val activityLastSyncedEntryTimestampArg = args[2] as Long
            val passiveLastSyncedTimestampArg = args[3] as Long
            api.getHeartRateData(uuidArg, activityLastSyncedBlockTimestampArg, activityLastSyncedEntryTimestampArg, passiveLastSyncedTimestampArg) { result: Result<RollaBandHeartRateSyncResponse> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBandHealthDataHostApi.getHRVData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            val lastSyncedBlockTimestampArg = args[1] as Long
            api.getHRVData(uuidArg, lastSyncedBlockTimestampArg) { result: Result<RollaBandHRVSyncResponse> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.rolla_band_sdk.RollaBandHealthDataHostApi.getSleepData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uuidArg = args[0] as String
            val lastSyncedBlockTimestampArg = args[1] as Long
            val lastSyncedEntryTimestampArg = args[2] as Long
            api.getSleepData(uuidArg, lastSyncedBlockTimestampArg, lastSyncedEntryTimestampArg) { result: Result<RollaBandSleepSyncResponse> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(MessagesPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(MessagesPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
